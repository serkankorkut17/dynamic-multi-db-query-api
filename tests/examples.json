[
  {
		"id": "recent_enrollments_30d",
		"description": "Enrollments in last 30 days per school",
		"dsl": "FETCH(sc.name, COUNT(e.id) AS recent_enrolls) FROM enrollments INCLUDE (student.class.school) FILTER(enrolled_at >= NOW() - INTERVAL '30 days') GROUPBY(sc.name) ORDERBY(recent_enrolls DESC)",
		"postgres": "SELECT sc.name, COUNT(e.id) AS recent_enrolls FROM enrollments e JOIN students st ON st.id = e.student_id JOIN classes cl ON cl.id = st.class_id JOIN schools sc ON sc.id = cl.school_id WHERE e.enrolled_at >= NOW() - INTERVAL '30 days' GROUP BY sc.name ORDER BY recent_enrolls DESC",
		"mysql": "SELECT sc.name, COUNT(e.id) AS recent_enrolls FROM enrollments e JOIN students st ON st.id = e.student_id JOIN classes cl ON cl.id = st.class_id JOIN schools sc ON sc.id = cl.school_id WHERE e.enrolled_at >= (NOW() - INTERVAL 30 DAY) GROUP BY sc.name ORDER BY recent_enrolls DESC",
		"mssql": "SELECT sc.name, COUNT(e.id) AS recent_enrolls FROM enrollments e JOIN students st ON st.id = e.student_id JOIN classes cl ON cl.id = st.class_id JOIN schools sc ON sc.id = cl.school_id WHERE e.enrolled_at >= DATEADD(DAY, -30, SYSDATETIME()) GROUP BY sc.name ORDER BY recent_enrolls DESC",
		"oracle": "SELECT sc.name, COUNT(e.id) recent_enrolls FROM enrollments e JOIN students st ON st.id = e.student_id JOIN classes cl ON cl.id = st.class_id JOIN schools sc ON sc.id = cl.school_id WHERE e.enrolled_at >= (SYSTIMESTAMP - INTERVAL '30' DAY) GROUP BY sc.name ORDER BY recent_enrolls DESC"
	},
	{
		"id": "agg_having_firstname_m",
		"description": "Count students by first_name containing 'm' (case-insensitive), only buckets >= 20",
		"dsl": "FETCH(first_name, COUNT(*)) FROM students FILTER(LOWER(first_name) CONTAINS 'm') GROUPBY(first_name) HAVING(COUNT(*) >= 20) ORDERBY(COUNT(*) DESC)",
		"postgres": "SELECT s.first_name, COUNT(*) AS cnt FROM students s WHERE LOWER(s.first_name) LIKE '%m%' GROUP BY s.first_name HAVING COUNT(*) >= 20 ORDER BY cnt DESC",
		"mysql": "SELECT s.first_name, COUNT(*) AS cnt FROM students s WHERE LOWER(s.first_name) LIKE '%m%' GROUP BY s.first_name HAVING COUNT(*) >= 20 ORDER BY cnt DESC",
		"mssql": "SELECT s.first_name, COUNT(*) AS cnt FROM students s WHERE LOWER(s.first_name) LIKE '%m%' GROUP BY s.first_name HAVING COUNT(*) >= 20 ORDER BY cnt DESC",
		"oracle": "SELECT s.first_name, COUNT(*) cnt FROM students s WHERE LOWER(s.first_name) LIKE '%m%' GROUP BY s.first_name HAVING COUNT(*) >= 20 ORDER BY cnt DESC"
	},
	{
		"id": "join_students_courses_progress",
		"description": "Average progress per course (only courses with > 30 enrollments)",
		"dsl": "FETCH(c.name, AVG(e.progress_percent) AS avg_progress, COUNT(*) AS enrolls) FROM enrollments INCLUDE (course) GROUPBY(c.name) HAVING(COUNT(*) > 30) ORDERBY(avg_progress DESC)",
		"postgres": "SELECT c.name, ROUND(AVG(e.progress_percent)::numeric,2) avg_progress, COUNT(*) enrolls FROM enrollments e JOIN courses c ON c.id = e.course_id GROUP BY c.name HAVING COUNT(*) > 30 ORDER BY avg_progress DESC",
		"mysql": "SELECT c.name, ROUND(AVG(e.progress_percent),2) AS avg_progress, COUNT(*) AS enrolls FROM enrollments e JOIN courses c ON c.id = e.course_id GROUP BY c.name HAVING COUNT(*) > 30 ORDER BY avg_progress DESC",
		"mssql": "SELECT c.name, ROUND(AVG(CAST(e.progress_percent AS FLOAT)),2) AS avg_progress, COUNT(*) AS enrolls FROM enrollments e JOIN courses c ON c.id = e.course_id GROUP BY c.name HAVING COUNT(*) > 30 ORDER BY avg_progress DESC",
		"oracle": "SELECT c.name, ROUND(AVG(e.progress_percent),2) avg_progress, COUNT(*) enrolls FROM enrollments e JOIN courses c ON c.id = e.course_id GROUP BY c.name HAVING COUNT(*) > 30 ORDER BY avg_progress DESC"
	},
	{
		"id": "json_zone_school_counts",
		"description": "Schools per metadata.zone (JSON) with > 1 school",
		"dsl": "FETCH(metadata, COUNT(*) AS school_count) FROM schools GROUPBY(metadata) HAVING(COUNT(*) > 1) ORDERBY(school_count DESC)",
		"postgres": "SELECT (metadata->>'zone') AS zone, COUNT(*) AS school_count FROM schools GROUP BY zone HAVING COUNT(*) > 1 ORDER BY school_count DESC",
		"mysql": "SELECT JSON_UNQUOTE(JSON_EXTRACT(metadata,'$.zone')) AS zone, COUNT(*) AS school_count FROM schools GROUP BY zone HAVING COUNT(*) > 1 ORDER BY school_count DESC",
		"mssql": "SELECT JSON_VALUE(metadata,'$.zone') AS zone, COUNT(*) AS school_count FROM schools GROUP BY JSON_VALUE(metadata,'$.zone') HAVING COUNT(*) > 1 ORDER BY school_count DESC",
		"oracle": "SELECT JSON_VALUE(metadata,'$.zone') AS zone, COUNT(*) AS school_count FROM schools GROUP BY JSON_VALUE(metadata,'$.zone') HAVING COUNT(*) > 1 ORDER BY school_count DESC"
	},
	{
		"id": "top5_schools_by_students",
		"description": "Top 5 schools by total students (different pagination syntax)",
		"dsl": "FETCH(sc.name, COUNT(st.id) AS student_count) FROM schools INCLUDE (classes.students) GROUPBY(sc.name) ORDERBY(student_count DESC) TAKE(5)",
		"postgres": "SELECT sc.name, COUNT(st.id) AS student_count FROM schools sc LEFT JOIN classes cl ON cl.school_id = sc.id LEFT JOIN students st ON st.class_id = cl.id GROUP BY sc.name ORDER BY student_count DESC LIMIT 5",
		"mysql": "SELECT sc.name, COUNT(st.id) AS student_count FROM schools sc LEFT JOIN classes cl ON cl.school_id = sc.id LEFT JOIN students st ON st.class_id = cl.id GROUP BY sc.name ORDER BY student_count DESC LIMIT 5",
		"mssql": "SELECT TOP 5 sc.name, COUNT(st.id) AS student_count FROM schools sc LEFT JOIN classes cl ON cl.school_id = sc.id LEFT JOIN students st ON st.class_id = cl.id GROUP BY sc.name ORDER BY student_count DESC",
		"oracle": "SELECT name, student_count FROM (SELECT sc.name AS name, COUNT(st.id) AS student_count, ROW_NUMBER() OVER (ORDER BY COUNT(st.id) DESC) rn FROM schools sc LEFT JOIN classes cl ON cl.school_id = sc.id LEFT JOIN students st ON st.class_id = cl.id GROUP BY sc.name) WHERE rn <= 5"
	},
	{
		"id": "pagination_students",
		"description": "Page 2 (size 10) active students ordered by last_name, first_name",
		"dsl": "FETCH(id, first_name, last_name) FROM students FILTER(is_active = TRUE) ORDERBY(last_name ASC, first_name ASC) LIMIT(10) OFFSET(10)",
		"postgres": "SELECT id, first_name, last_name FROM students WHERE is_active = TRUE ORDER BY last_name, first_name LIMIT 10 OFFSET 10",
		"mysql": "SELECT id, first_name, last_name FROM students WHERE is_active = 1 ORDER BY last_name, first_name LIMIT 10 OFFSET 10",
		"mssql": "SELECT id, first_name, last_name FROM students WHERE is_active = 1 ORDER BY last_name, first_name OFFSET 10 ROWS FETCH NEXT 10 ROWS ONLY",
		"oracle": "SELECT id, first_name, last_name FROM students WHERE is_active = 1 ORDER BY last_name, first_name OFFSET 10 ROWS FETCH NEXT 10 ROWS ONLY"
	},
	{
		"id": "gpa_above_avg_per_class",
		"description": "Students whose GPA is above their class average (self aggregate)",
		"dsl": "FETCH(st.id, st.first_name, st.last_name, st.gpa) FROM students AS st INCLUDE(class) FILTER(st.gpa IS NOT NULL AND st.gpa > AVG(class.students.gpa) OVER class) ORDERBY(st.gpa DESC)",
		"postgres": "SELECT st.id, st.first_name, st.last_name, st.gpa FROM students st JOIN (SELECT class_id, AVG(gpa) avg_gpa FROM students WHERE gpa IS NOT NULL GROUP BY class_id) a ON a.class_id = st.class_id WHERE st.gpa IS NOT NULL AND st.gpa > a.avg_gpa ORDER BY st.gpa DESC",
		"mysql": "SELECT st.id, st.first_name, st.last_name, st.gpa FROM students st JOIN (SELECT class_id, AVG(gpa) avg_gpa FROM students WHERE gpa IS NOT NULL GROUP BY class_id) a ON a.class_id = st.class_id WHERE st.gpa IS NOT NULL AND st.gpa > a.avg_gpa ORDER BY st.gpa DESC",
		"mssql": "SELECT st.id, st.first_name, st.last_name, st.gpa FROM students st JOIN (SELECT class_id, AVG(gpa) avg_gpa FROM students WHERE gpa IS NOT NULL GROUP BY class_id) a ON a.class_id = st.class_id WHERE st.gpa IS NOT NULL AND st.gpa > a.avg_gpa ORDER BY st.gpa DESC",
		"oracle": "SELECT st.id, st.first_name, st.last_name, st.gpa FROM students st JOIN (SELECT class_id, AVG(gpa) avg_gpa FROM students WHERE gpa IS NOT NULL GROUP BY class_id) a ON a.class_id = st.class_id WHERE st.gpa IS NOT NULL AND st.gpa > a.avg_gpa ORDER BY st.gpa DESC"
	},
	{
		"id": "teacher_load",
		"description": "Teachers with number of distinct classes (via school) and courses at that school",
		"dsl": "FETCH(t.id, t.first_name, t.last_name, COUNT(DISTINCT cl.id) AS class_count, COUNT(DISTINCT co.id) AS course_count) FROM teachers AS t INCLUDE(school.classes AS cl, school.courses AS co) GROUPBY(t.id, t.first_name, t.last_name) ORDERBY(class_count DESC, course_count DESC)",
		"postgres": "SELECT t.id, t.first_name, t.last_name, COUNT(DISTINCT cl.id) AS class_count, COUNT(DISTINCT co.id) AS course_count FROM teachers t LEFT JOIN schools sc ON sc.id = t.school_id LEFT JOIN classes cl ON cl.school_id = sc.id LEFT JOIN courses co ON co.school_id = sc.id GROUP BY t.id, t.first_name, t.last_name ORDER BY class_count DESC, course_count DESC",
		"mysql": "SELECT t.id, t.first_name, t.last_name, COUNT(DISTINCT cl.id) AS class_count, COUNT(DISTINCT co.id) AS course_count FROM teachers t LEFT JOIN schools sc ON sc.id = t.school_id LEFT JOIN classes cl ON cl.school_id = sc.id LEFT JOIN courses co ON co.school_id = sc.id GROUP BY t.id, t.first_name, t.last_name ORDER BY class_count DESC, course_count DESC",
		"mssql": "SELECT t.id, t.first_name, t.last_name, COUNT(DISTINCT cl.id) AS class_count, COUNT(DISTINCT co.id) AS course_count FROM teachers t LEFT JOIN schools sc ON sc.id = t.school_id LEFT JOIN classes cl ON cl.school_id = sc.id LEFT JOIN courses co ON co.school_id = sc.id GROUP BY t.id, t.first_name, t.last_name ORDER BY class_count DESC, course_count DESC",
		"oracle": "SELECT t.id, t.first_name, t.last_name, COUNT(DISTINCT cl.id) class_count, COUNT(DISTINCT co.id) course_count FROM teachers t LEFT JOIN schools sc ON sc.id = t.school_id LEFT JOIN classes cl ON cl.school_id = sc.id LEFT JOIN courses co ON co.school_id = sc.id GROUP BY t.id, t.first_name, t.last_name ORDER BY class_count DESC, course_count DESC"
	},
	{
		"id": "courses_enrollment_ratio",
		"description": "Enrollment count and pass ratio per course (progress > 50 as passed proxy if no grade table join)",
		"dsl": "FETCH(c.name, COUNT(e.id) AS enrollments, (100 * AVG(CASE WHEN e.progress_percent >= 50 THEN 1 ELSE 0 END)) AS pass_pct) FROM courses INCLUDE(enrollments) GROUPBY(c.name) ORDERBY(pass_pct DESC)",
		"postgres": "SELECT c.name, COUNT(e.id) enrollments, ROUND(100.0 * AVG(CASE WHEN e.progress_percent >= 50 THEN 1 ELSE 0 END)::numeric,1) pass_pct FROM courses c LEFT JOIN enrollments e ON e.course_id = c.id GROUP BY c.name ORDER BY pass_pct DESC",
		"mysql": "SELECT c.name, COUNT(e.id) AS enrollments, ROUND(100.0 * AVG(CASE WHEN e.progress_percent >= 50 THEN 1 ELSE 0 END),1) AS pass_pct FROM courses c LEFT JOIN enrollments e ON e.course_id = c.id GROUP BY c.name ORDER BY pass_pct DESC",
		"mssql": "SELECT c.name, COUNT(e.id) AS enrollments, ROUND(100.0 * AVG(CASE WHEN e.progress_percent >= 50 THEN 1 ELSE 0 END),1) AS pass_pct FROM courses c LEFT JOIN enrollments e ON e.course_id = c.id GROUP BY c.name ORDER BY pass_pct DESC",
		"oracle": "SELECT c.name, COUNT(e.id) enrollments, ROUND(100 * AVG(CASE WHEN e.progress_percent >= 50 THEN 1 ELSE 0 END),1) pass_pct FROM courses c LEFT JOIN enrollments e ON e.course_id = c.id GROUP BY c.name ORDER BY pass_pct DESC"
	},
	{
		"id": "capacity_vs_students_zone",
		"description": "Compare total metadata.capacity (sum) vs actual student count per zone",
		"dsl": "FETCH(metadata.zone, SUM(metadata.capacity) AS planned_capacity, COUNT(st.id) AS student_count) FROM schools INCLUDE(classes.students AS st) GROUPBY(metadata.zone) ORDERBY(student_count DESC)",
		"postgres": "SELECT (metadata->>'zone') AS zone, SUM((metadata->>'capacity')::int) AS planned_capacity, COUNT(st.id) AS student_count FROM schools sc LEFT JOIN classes cl ON cl.school_id = sc.id LEFT JOIN students st ON st.class_id = cl.id GROUP BY zone ORDER BY student_count DESC",
		"mysql": "SELECT JSON_UNQUOTE(JSON_EXTRACT(sc.metadata,'$.zone')) AS zone, SUM(JSON_EXTRACT(sc.metadata,'$.capacity')) AS planned_capacity, COUNT(st.id) AS student_count FROM schools sc LEFT JOIN classes cl ON cl.school_id = sc.id LEFT JOIN students st ON st.class_id = cl.id GROUP BY zone ORDER BY student_count DESC",
		"mssql": "SELECT JSON_VALUE(sc.metadata,'$.zone') AS zone, SUM(TRY_CAST(JSON_VALUE(sc.metadata,'$.capacity') AS INT)) AS planned_capacity, COUNT(st.id) AS student_count FROM schools sc LEFT JOIN classes cl ON cl.school_id = sc.id LEFT JOIN students st ON st.class_id = cl.id GROUP BY JSON_VALUE(sc.metadata,'$.zone') ORDER BY student_count DESC",
		"oracle": "SELECT JSON_VALUE(sc.metadata,'$.zone') AS zone, SUM(TO_NUMBER(JSON_VALUE(sc.metadata,'$.capacity'))) AS planned_capacity, COUNT(st.id) AS student_count FROM schools sc LEFT JOIN classes cl ON cl.school_id = sc.id LEFT JOIN students st ON st.class_id = cl.id GROUP BY JSON_VALUE(sc.metadata,'$.zone') ORDER BY student_count DESC"
	}
	,
	{
		"id": "students_active_email_pattern",
		"description": "Active students whose email ends with .tr and contains @",
		"dsl": "FETCH(id, first_name, last_name, email) FROM students FILTER(is_active = TRUE AND email CONTAINS '@' AND email ENDSWITH '.tr') ORDERBY(last_name ASC, first_name ASC) LIMIT(20)",
		"postgres": "SELECT id, first_name, last_name, email FROM students WHERE is_active = TRUE AND email LIKE '%@%' AND email LIKE '%.tr' ORDER BY last_name, first_name LIMIT 20",
		"mysql": "SELECT id, first_name, last_name, email FROM students WHERE is_active = 1 AND email LIKE '%@%' AND email LIKE '%.tr' ORDER BY last_name, first_name LIMIT 20",
		"mssql": "SELECT TOP 20 id, first_name, last_name, email FROM students WHERE is_active = 1 AND email LIKE '%@%' AND email LIKE '%.tr' ORDER BY last_name, first_name",
		"oracle": "SELECT id, first_name, last_name, email FROM students WHERE is_active = 1 AND email LIKE '%@%' AND email LIKE '%.tr' ORDER BY last_name, first_name FETCH FIRST 20 ROWS ONLY"
	},
	{
		"id": "classes_student_count_ge_25",
		"description": "Classes with at least 25 students",
		"dsl": "FETCH(cl.id, cl.name, COUNT(st.id) AS student_count) FROM classes AS cl INCLUDE(students AS st) GROUPBY(cl.id, cl.name) HAVING(COUNT(st.id) >= 25) ORDERBY(student_count DESC)",
		"postgres": "SELECT cl.id, cl.name, COUNT(st.id) AS student_count FROM classes cl LEFT JOIN students st ON st.class_id = cl.id GROUP BY cl.id, cl.name HAVING COUNT(st.id) >= 25 ORDER BY student_count DESC",
		"mysql": "SELECT cl.id, cl.name, COUNT(st.id) AS student_count FROM classes cl LEFT JOIN students st ON st.class_id = cl.id GROUP BY cl.id, cl.name HAVING COUNT(st.id) >= 25 ORDER BY student_count DESC",
		"mssql": "SELECT cl.id, cl.name, COUNT(st.id) AS student_count FROM classes cl LEFT JOIN students st ON st.class_id = cl.id GROUP BY cl.id, cl.name HAVING COUNT(st.id) >= 25 ORDER BY student_count DESC",
		"oracle": "SELECT cl.id, cl.name, COUNT(st.id) student_count FROM classes cl LEFT JOIN students st ON st.class_id = cl.id GROUP BY cl.id, cl.name HAVING COUNT(st.id) >= 25 ORDER BY student_count DESC"
	},
	{
		"id": "courses_elective_distribution",
		"description": "Count courses grouped by is_elective flag",
		"dsl": "FETCH(is_elective, COUNT(*) AS course_count) FROM courses GROUPBY(is_elective) ORDERBY(course_count DESC)",
		"postgres": "SELECT is_elective, COUNT(*) AS course_count FROM courses GROUP BY is_elective ORDER BY course_count DESC",
		"mysql": "SELECT is_elective, COUNT(*) AS course_count FROM courses GROUP BY is_elective ORDER BY course_count DESC",
		"mssql": "SELECT is_elective, COUNT(*) AS course_count FROM courses GROUP BY is_elective ORDER BY course_count DESC",
		"oracle": "SELECT is_elective, COUNT(*) course_count FROM courses GROUP BY is_elective ORDER BY course_count DESC"
	},
	{
		"id": "schools_public_private_split",
		"description": "Public vs private school counts",
		"dsl": "FETCH(is_public, COUNT(*) AS school_count) FROM schools GROUPBY(is_public) ORDERBY(school_count DESC)",
		"postgres": "SELECT is_public, COUNT(*) AS school_count FROM schools GROUP BY is_public ORDER BY school_count DESC",
		"mysql": "SELECT is_public, COUNT(*) AS school_count FROM schools GROUP BY is_public ORDER BY school_count DESC",
		"mssql": "SELECT is_public, COUNT(*) AS school_count FROM schools GROUP BY is_public ORDER BY school_count DESC",
		"oracle": "SELECT is_public, COUNT(*) school_count FROM schools GROUP BY is_public ORDER BY school_count DESC"
	},
	{
		"id": "teacher_salary_stats",
		"description": "Aggregate salary stats per school (AVG, MIN, MAX)",
		"dsl": "FETCH(school_id, AVG(salary) AS avg_salary, MIN(salary) AS min_salary, MAX(salary) AS max_salary) FROM teachers GROUPBY(school_id) HAVING(COUNT(*) > 2) ORDERBY(avg_salary DESC)",
		"postgres": "SELECT school_id, AVG(salary) AS avg_salary, MIN(salary) AS min_salary, MAX(salary) AS max_salary FROM teachers GROUP BY school_id HAVING COUNT(*) > 2 ORDER BY avg_salary DESC",
		"mysql": "SELECT school_id, AVG(salary) AS avg_salary, MIN(salary) AS min_salary, MAX(salary) AS max_salary FROM teachers GROUP BY school_id HAVING COUNT(*) > 2 ORDER BY avg_salary DESC",
		"mssql": "SELECT school_id, AVG(salary) AS avg_salary, MIN(salary) AS min_salary, MAX(salary) AS max_salary FROM teachers GROUP BY school_id HAVING COUNT(*) > 2 ORDER BY avg_salary DESC",
		"oracle": "SELECT school_id, AVG(salary) avg_salary, MIN(salary) min_salary, MAX(salary) max_salary FROM teachers GROUP BY school_id HAVING COUNT(*) > 2 ORDER BY avg_salary DESC"
	},
	{
		"id": "students_gpa_high_active",
		"description": "Active students with GPA >= 3.5 (top 15)",
		"dsl": "FETCH(id, first_name, last_name, gpa) FROM students FILTER(is_active = TRUE AND gpa >= 3.5) ORDERBY(gpa DESC) LIMIT(15)",
		"postgres": "SELECT id, first_name, last_name, gpa FROM students WHERE is_active = TRUE AND gpa >= 3.5 ORDER BY gpa DESC LIMIT 15",
		"mysql": "SELECT id, first_name, last_name, gpa FROM students WHERE is_active = 1 AND gpa >= 3.5 ORDER BY gpa DESC LIMIT 15",
		"mssql": "SELECT TOP 15 id, first_name, last_name, gpa FROM students WHERE is_active = 1 AND gpa >= 3.5 ORDER BY gpa DESC",
		"oracle": "SELECT id, first_name, last_name, gpa FROM students WHERE is_active = 1 AND gpa >= 3.5 ORDER BY gpa DESC FETCH FIRST 15 ROWS ONLY"
	},
	{
		"id": "students_null_email",
		"description": "Students with NULL email (data quality check)",
		"dsl": "FETCH(id, first_name, last_name) FROM students FILTER(email IS NULL) LIMIT(20)",
		"postgres": "SELECT id, first_name, last_name FROM students WHERE email IS NULL LIMIT 20",
		"mysql": "SELECT id, first_name, last_name FROM students WHERE email IS NULL LIMIT 20",
		"mssql": "SELECT TOP 20 id, first_name, last_name FROM students WHERE email IS NULL",
		"oracle": "SELECT id, first_name, last_name FROM students WHERE email IS NULL FETCH FIRST 20 ROWS ONLY"
	},
	{
		"id": "enrollments_progress_band_mid",
		"description": "Enrollments with progress between 40 and 60 inclusive",
		"dsl": "FETCH(id, student_id, course_id, progress_percent) FROM enrollments FILTER(progress_percent >= 40 AND progress_percent <= 60) ORDERBY(progress_percent ASC) LIMIT(30)",
		"postgres": "SELECT id, student_id, course_id, progress_percent FROM enrollments WHERE progress_percent >= 40 AND progress_percent <= 60 ORDER BY progress_percent ASC LIMIT 30",
		"mysql": "SELECT id, student_id, course_id, progress_percent FROM enrollments WHERE progress_percent >= 40 AND progress_percent <= 60 ORDER BY progress_percent ASC LIMIT 30",
		"mssql": "SELECT TOP 30 id, student_id, course_id, progress_percent FROM enrollments WHERE progress_percent >= 40 AND progress_percent <= 60 ORDER BY progress_percent ASC",
		"oracle": "SELECT id, student_id, course_id, progress_percent FROM enrollments WHERE progress_percent >= 40 AND progress_percent <= 60 ORDER BY progress_percent ASC FETCH FIRST 30 ROWS ONLY"
	},
	{
		"id": "students_order_pagination_alt",
		"description": "Alternate pagination: first 10 after skipping 5 by name",
		"dsl": "FETCH(id, first_name, last_name) FROM students ORDERBY(first_name ASC) LIMIT(10) OFFSET(5)",
		"postgres": "SELECT id, first_name, last_name FROM students ORDER BY first_name LIMIT 10 OFFSET 5",
		"mysql": "SELECT id, first_name, last_name FROM students ORDER BY first_name LIMIT 10 OFFSET 5",
		"mssql": "SELECT id, first_name, last_name FROM students ORDER BY first_name OFFSET 5 ROWS FETCH NEXT 10 ROWS ONLY",
		"oracle": "SELECT id, first_name, last_name FROM students ORDER BY first_name OFFSET 5 ROWS FETCH NEXT 10 ROWS ONLY"
	},
	{
		"old":"--- IGNORE ---",
		"dsl": "FETCH(CONCAT(LOWER(first_name), '-', UPPER(last_name)) AS name, COUNT(*) AS total) FROM students FILTER(ISNULL(first_name, 'noname') CONTAINS LOWER('T')) GROUPBY(name) ORDERBY(total DESC)",
		"postgres": "SELECT CONCAT(LOWER(first_name), '-', UPPER(last_name)) AS name, COUNT(*) AS total FROM students WHERE ISNULL(first_name, 'noname') LIKE LOWER('%T%') GROUP BY name ORDER BY total DESC",
		"mysql": "SELECT CONCAT(LOWER(first_name), '-', UPPER(last_name)) AS name, COUNT(*) AS total FROM students WHERE IFNULL(first_name, 'noname') LIKE LOWER('%T%') GROUP BY name ORDER BY total DESC",
		"mssql": "SELECT CONCAT(LOWER(first_name), '-', UPPER(last_name)) AS name, COUNT(*) AS total FROM students WHERE ISNULL(first_name, 'noname') LIKE LOWER('%T%') GROUP BY name ORDER BY total DESC",
		"oracle": "SELECT CONCAT(LOWER(first_name), '-', UPPER(last_name)) AS name, COUNT(*) AS total FROM students WHERE NVL(first_name, 'noname') LIKE LOWER('%T%') GROUP BY name ORDER BY total DESC"
	}
,
	{
		"id": "students_age_distribution",
		"description": "Student age distribution by years (top 10 buckets)",
		"dsl": "FETCH(DATEDIFF('year', birth_date, CURRENT_DATE) AS age, COUNT(*) AS cnt) FROM students GROUPBY(age) ORDERBY(cnt DESC) LIMIT(10)",
		"postgres": "SELECT DATE_PART('year', AGE(CURRENT_DATE, birth_date)) AS age, COUNT(*) AS cnt FROM students GROUP BY DATE_PART('year', AGE(CURRENT_DATE, birth_date)) ORDER BY cnt DESC LIMIT 10",
		"mysql": "SELECT TIMESTAMPDIFF(YEAR, birth_date, CURRENT_DATE()) AS age, COUNT(*) AS cnt FROM students GROUP BY TIMESTAMPDIFF(YEAR, birth_date, CURRENT_DATE()) ORDER BY cnt DESC LIMIT 10",
		"mssql": "SELECT TOP 10 DATEDIFF(year, birth_date, CAST(GETDATE() AS date)) AS age, COUNT(*) AS cnt FROM students GROUP BY DATEDIFF(year, birth_date, CAST(GETDATE() AS date)) ORDER BY cnt DESC",
		"oracle": "SELECT age, cnt FROM (SELECT FLOOR(MONTHS_BETWEEN(TRUNC(SYSDATE), birth_date)/12) AS age, COUNT(*) AS cnt FROM students GROUP BY FLOOR(MONTHS_BETWEEN(TRUNC(SYSDATE), birth_date)/12)) t ORDER BY cnt DESC FETCH FIRST 10 ROWS ONLY"
	},
	{
		"id": "support_needs_by_class",
		"description": "Students needing support per class (top 5)",
		"dsl": "FETCH(cl.name, COUNT(st.id) AS support_count) FROM classes AS cl INCLUDE(students AS st) FILTER(st.preferences.needs_support = TRUE) GROUPBY(cl.name) ORDERBY(support_count DESC) LIMIT(5)",
		"postgres": "SELECT cl.name, COUNT(st.id) AS support_count FROM classes cl LEFT JOIN students st ON st.class_id = cl.id WHERE (st.preferences->>'needs_support')::boolean = TRUE GROUP BY cl.name ORDER BY support_count DESC LIMIT 5",
		"mysql": "SELECT cl.name, COUNT(st.id) AS support_count FROM classes cl LEFT JOIN students st ON st.class_id = cl.id WHERE JSON_EXTRACT(st.preferences,'$.needs_support') = true GROUP BY cl.name ORDER BY support_count DESC LIMIT 5",
		"mssql": "SELECT TOP 5 cl.name, COUNT(st.id) AS support_count FROM classes cl LEFT JOIN students st ON st.class_id = cl.id WHERE JSON_VALUE(st.preferences,'$.needs_support') = 'true' GROUP BY cl.name ORDER BY support_count DESC",
		"oracle": "SELECT cl.name, COUNT(st.id) support_count FROM classes cl LEFT JOIN students st ON st.class_id = cl.id WHERE JSON_VALUE(st.preferences,'$.needs_support') = 'true' GROUP BY cl.name ORDER BY support_count DESC FETCH FIRST 5 ROWS ONLY"
	},
	{
		"id": "students_firstname_startswith_a",
		"description": "Students whose first name starts with 'A' (first 20)",
		"dsl": "FETCH(id, first_name) FROM students FILTER(first_name STARTSWITH 'A') ORDERBY(first_name ASC) LIMIT(20)",
		"postgres": "SELECT id, first_name FROM students WHERE first_name LIKE 'A%' ORDER BY first_name LIMIT 20",
		"mysql": "SELECT id, first_name FROM students WHERE first_name LIKE 'A%' ORDER BY first_name LIMIT 20",
		"mssql": "SELECT TOP 20 id, first_name FROM students WHERE first_name LIKE 'A%' ORDER BY first_name",
		"oracle": "SELECT id, first_name FROM students WHERE first_name LIKE 'A%' ORDER BY first_name FETCH FIRST 20 ROWS ONLY"
	},
	{
		"id": "grades_between_50_70",
		"description": "Enrollments with grades between 50 and 70 (desc by grade)",
		"dsl": "FETCH(e.id, g.grade) FROM enrollments AS e INCLUDE(grades AS g) FILTER(g.grade BETWEEN 50 AND 70) ORDERBY(g.grade DESC) LIMIT(20)",
		"postgres": "SELECT e.id, g.grade FROM enrollments e JOIN grades g ON g.enrollment_id = e.id WHERE g.grade BETWEEN 50 AND 70 ORDER BY g.grade DESC LIMIT 20",
		"mysql": "SELECT e.id, g.grade FROM enrollments e JOIN grades g ON g.enrollment_id = e.id WHERE g.grade BETWEEN 50 AND 70 ORDER BY g.grade DESC LIMIT 20",
		"mssql": "SELECT TOP 20 e.id, g.grade FROM enrollments e JOIN grades g ON g.enrollment_id = e.id WHERE g.grade BETWEEN 50 AND 70 ORDER BY g.grade DESC",
		"oracle": "SELECT e.id, g.grade FROM enrollments e JOIN grades g ON g.enrollment_id = e.id WHERE g.grade BETWEEN 50 AND 70 ORDER BY g.grade DESC FETCH FIRST 20 ROWS ONLY"
	},
	{
		"id": "students_gpa_band_case",
		"description": "Assign GPA band A/B/C/D via IFS (first 30)",
		"dsl": "FETCH(st.id, st.first_name, IFS(st.gpa >= 3.5, 'A', st.gpa >= 3.0, 'B', st.gpa >= 2.5, 'C', 'D') AS gpa_band) FROM students AS st ORDERBY(gpa_band ASC, st.last_name ASC) LIMIT(30)",
		"postgres": "SELECT st.id, st.first_name, CASE WHEN st.gpa >= 3.5 THEN 'A' WHEN st.gpa >= 3.0 THEN 'B' WHEN st.gpa >= 2.5 THEN 'C' ELSE 'D' END AS gpa_band FROM students st ORDER BY gpa_band, st.last_name LIMIT 30",
		"mysql": "SELECT st.id, st.first_name, CASE WHEN st.gpa >= 3.5 THEN 'A' WHEN st.gpa >= 3.0 THEN 'B' WHEN st.gpa >= 2.5 THEN 'C' ELSE 'D' END AS gpa_band FROM students st ORDER BY gpa_band, st.last_name LIMIT 30",
		"mssql": "SELECT TOP 30 st.id, st.first_name, CASE WHEN st.gpa >= 3.5 THEN 'A' WHEN st.gpa >= 3.0 THEN 'B' WHEN st.gpa >= 2.5 THEN 'C' ELSE 'D' END AS gpa_band FROM students st ORDER BY gpa_band, st.last_name",
		"oracle": "SELECT st.id, st.first_name, CASE WHEN st.gpa >= 3.5 THEN 'A' WHEN st.gpa >= 3.0 THEN 'B' WHEN st.gpa >= 2.5 THEN 'C' ELSE 'D' END gpa_band FROM students st ORDER BY gpa_band, st.last_name FETCH FIRST 30 ROWS ONLY"
	},
	{
		"id": "courses_enroll_alias_having",
		"description": "Use alias in HAVING: courses with enroll_cnt > 5",
		"dsl": "FETCH(c.name, COUNT(e.id) AS enroll_cnt) FROM courses AS c INCLUDE(enrollments AS e) GROUPBY(c.name) HAVING(enroll_cnt > 5) ORDERBY(enroll_cnt DESC)",
		"postgres": "SELECT c.name, COUNT(e.id) AS enroll_cnt FROM courses c LEFT JOIN enrollments e ON e.course_id = c.id GROUP BY c.name HAVING COUNT(e.id) > 5 ORDER BY enroll_cnt DESC",
		"mysql": "SELECT c.name, COUNT(e.id) AS enroll_cnt FROM courses c LEFT JOIN enrollments e ON e.course_id = c.id GROUP BY c.name HAVING COUNT(e.id) > 5 ORDER BY enroll_cnt DESC",
		"mssql": "SELECT c.name, COUNT(e.id) AS enroll_cnt FROM courses c LEFT JOIN enrollments e ON e.course_id = c.id GROUP BY c.name HAVING COUNT(e.id) > 5 ORDER BY enroll_cnt DESC",
		"oracle": "SELECT c.name, COUNT(e.id) enroll_cnt FROM courses c LEFT JOIN enrollments e ON e.course_id = c.id GROUP BY c.name HAVING COUNT(e.id) > 5 ORDER BY enroll_cnt DESC"
	},
	{
		"id": "students_first_longer_than_last",
		"description": "Students where first_name length > last_name length (first 15)",
		"dsl": "FETCH(id, first_name, last_name) FROM students FILTER(LENGTH(first_name) > LENGTH(last_name)) LIMIT(15)",
		"postgres": "SELECT id, first_name, last_name FROM students WHERE LENGTH(first_name) > LENGTH(last_name) LIMIT 15",
		"mysql": "SELECT id, first_name, last_name FROM students WHERE CHAR_LENGTH(first_name) > CHAR_LENGTH(last_name) LIMIT 15",
		"mssql": "SELECT TOP 15 id, first_name, last_name FROM students WHERE LEN(first_name) > LEN(last_name)",
		"oracle": "SELECT id, first_name, last_name FROM students WHERE LENGTH(first_name) > LENGTH(last_name) FETCH FIRST 15 ROWS ONLY"
	},
	{
		"id": "enrollments_by_year_month",
		"description": "Enrollment counts grouped by year and month (latest 12)",
		"dsl": "FETCH(YEAR(enrolled_at) AS yr, MONTH(enrolled_at) AS mo, COUNT(*) AS cnt) FROM enrollments GROUPBY(yr, mo) ORDERBY(yr DESC, mo DESC) LIMIT(12)",
		"postgres": "SELECT EXTRACT(YEAR FROM enrolled_at) AS yr, EXTRACT(MONTH FROM enrolled_at) AS mo, COUNT(*) AS cnt FROM enrollments GROUP BY EXTRACT(YEAR FROM enrolled_at), EXTRACT(MONTH FROM enrolled_at) ORDER BY yr DESC, mo DESC LIMIT 12",
		"mysql": "SELECT YEAR(enrolled_at) AS yr, MONTH(enrolled_at) AS mo, COUNT(*) AS cnt FROM enrollments GROUP BY YEAR(enrolled_at), MONTH(enrolled_at) ORDER BY yr DESC, mo DESC LIMIT 12",
		"mssql": "SELECT TOP 12 YEAR(enrolled_at) AS yr, MONTH(enrolled_at) AS mo, COUNT(*) AS cnt FROM enrollments GROUP BY YEAR(enrolled_at), MONTH(enrolled_at) ORDER BY yr DESC, mo DESC",
		"oracle": "SELECT EXTRACT(YEAR FROM enrolled_at) AS yr, EXTRACT(MONTH FROM enrolled_at) AS mo, COUNT(*) AS cnt FROM enrollments GROUP BY EXTRACT(YEAR FROM enrolled_at), EXTRACT(MONTH FROM enrolled_at) ORDER BY yr DESC, mo DESC FETCH FIRST 12 ROWS ONLY"
	},
	{
		"id": "teachers_hired_last_5y",
		"description": "Teachers hired in the last 5 years (latest 20)",
		"dsl": "FETCH(first_name, last_name, hire_date) FROM teachers FILTER(hire_date >= CURRENT_DATE - INTERVAL '5 years') ORDERBY(hire_date DESC) LIMIT(20)",
		"postgres": "SELECT first_name, last_name, hire_date FROM teachers WHERE hire_date >= (CURRENT_DATE - INTERVAL '5 years') ORDER BY hire_date DESC LIMIT 20",
		"mysql": "SELECT first_name, last_name, hire_date FROM teachers WHERE hire_date >= (CURRENT_DATE - INTERVAL 5 YEAR) ORDER BY hire_date DESC LIMIT 20",
		"mssql": "SELECT TOP 20 first_name, last_name, hire_date FROM teachers WHERE hire_date >= DATEADD(YEAR, -5, CAST(GETDATE() AS date)) ORDER BY hire_date DESC",
		"oracle": "SELECT first_name, last_name, hire_date FROM teachers WHERE hire_date >= (TRUNC(SYSDATE) - INTERVAL '5' YEAR) ORDER BY hire_date DESC FETCH FIRST 20 ROWS ONLY"
	},
	{
		"id": "schools_city_inclusion",
		"description": "Schools in the three largest cities",
		"dsl": "FETCH(name, city) FROM schools FILTER(city IN ('İstanbul','Ankara','İzmir')) ORDERBY(city ASC, name ASC) LIMIT(20)",
		"postgres": "SELECT name, city FROM schools WHERE city IN ('İstanbul','Ankara','İzmir') ORDER BY city, name LIMIT 20",
		"mysql": "SELECT name, city FROM schools WHERE city IN ('İstanbul','Ankara','İzmir') ORDER BY city, name LIMIT 20",
		"mssql": "SELECT TOP 20 name, city FROM schools WHERE city IN (N'İstanbul', N'Ankara', N'İzmir') ORDER BY city, name",
		"oracle": "SELECT name, city FROM schools WHERE city IN ('İstanbul','Ankara','İzmir') ORDER BY city, name FETCH FIRST 20 ROWS ONLY"
	},
	{
		"id": "student_email_domains",
		"description": "Top 5 student email domains",
		"dsl": "FETCH(SUBSTRING(email, INDEXOF(email,'@')+1) AS domain, COUNT(*) AS cnt) FROM students GROUPBY(domain) ORDERBY(cnt DESC) LIMIT(5)",
		"postgres": "SELECT SPLIT_PART(email,'@',2) AS domain, COUNT(*) AS cnt FROM students GROUP BY SPLIT_PART(email,'@',2) ORDER BY cnt DESC LIMIT 5",
		"mysql": "SELECT SUBSTRING_INDEX(email,'@',-1) AS domain, COUNT(*) AS cnt FROM students GROUP BY SUBSTRING_INDEX(email,'@',-1) ORDER BY cnt DESC LIMIT 5",
		"mssql": "SELECT SUBSTRING(email, CHARINDEX('@',email)+1, LEN(email)) AS domain, COUNT(*) AS cnt FROM students GROUP BY SUBSTRING(email, CHARINDEX('@',email)+1, LEN(email)) ORDER BY cnt DESC",
		"oracle": "SELECT SUBSTR(email, INSTR(email,'@')+1) AS domain, COUNT(*) AS cnt FROM students GROUP BY SUBSTR(email, INSTR(email,'@')+1) ORDER BY cnt DESC FETCH FIRST 5 ROWS ONLY"
	},
	{
		"id": "enrollments_last7_by_ymd",
		"description": "Enrollments in last 7 days grouped by Y/M/D",
		"dsl": "FETCH(YEAR(enrolled_at) AS yr, MONTH(enrolled_at) AS mo, DAY(enrolled_at) AS dy, COUNT(*) AS cnt) FROM enrollments FILTER(enrolled_at >= NOW() - INTERVAL '7 days') GROUPBY(yr, mo, dy) ORDERBY(yr DESC, mo DESC, dy DESC)",
		"postgres": "SELECT EXTRACT(YEAR FROM enrolled_at) AS yr, EXTRACT(MONTH FROM enrolled_at) AS mo, EXTRACT(DAY FROM enrolled_at) AS dy, COUNT(*) AS cnt FROM enrollments WHERE enrolled_at >= NOW() - INTERVAL '7 days' GROUP BY EXTRACT(YEAR FROM enrolled_at), EXTRACT(MONTH FROM enrolled_at), EXTRACT(DAY FROM enrolled_at) ORDER BY yr DESC, mo DESC, dy DESC",
		"mysql": "SELECT YEAR(enrolled_at) AS yr, MONTH(enrolled_at) AS mo, DAY(enrolled_at) AS dy, COUNT(*) AS cnt FROM enrollments WHERE enrolled_at >= (NOW() - INTERVAL 7 DAY) GROUP BY YEAR(enrolled_at), MONTH(enrolled_at), DAY(enrolled_at) ORDER BY yr DESC, mo DESC, dy DESC",
		"mssql": "SELECT YEAR(enrolled_at) AS yr, MONTH(enrolled_at) AS mo, DAY(enrolled_at) AS dy, COUNT(*) AS cnt FROM enrollments WHERE enrolled_at >= DATEADD(DAY, -7, SYSDATETIME()) GROUP BY YEAR(enrolled_at), MONTH(enrolled_at), DAY(enrolled_at) ORDER BY yr DESC, mo DESC, dy DESC",
		"oracle": "SELECT EXTRACT(YEAR FROM enrolled_at) AS yr, EXTRACT(MONTH FROM enrolled_at) AS mo, EXTRACT(DAY FROM enrolled_at) AS dy, COUNT(*) AS cnt FROM enrollments WHERE enrolled_at >= (SYSTIMESTAMP - INTERVAL '7' DAY) GROUP BY EXTRACT(YEAR FROM enrolled_at), EXTRACT(MONTH FROM enrolled_at), EXTRACT(DAY FROM enrolled_at) ORDER BY yr DESC, mo DESC, dy DESC"
	},
	{
		"id": "schools_established_pre_2000",
		"description": "Schools established before or in 2000",
		"dsl": "FETCH(id, name, established_year) FROM schools FILTER(established_year <= 2000) ORDERBY(established_year ASC, name ASC) LIMIT(20)",
		"postgres": "SELECT id, name, established_year FROM schools WHERE established_year <= 2000 ORDER BY established_year, name LIMIT 20",
		"mysql": "SELECT id, name, established_year FROM schools WHERE established_year <= 2000 ORDER BY established_year, name LIMIT 20",
		"mssql": "SELECT TOP 20 id, name, established_year FROM schools WHERE established_year <= 2000 ORDER BY established_year, name",
		"oracle": "SELECT id, name, established_year FROM schools WHERE established_year <= 2000 ORDER BY established_year, name FETCH FIRST 20 ROWS ONLY"
	},
	{
		"id": "avg_grade_per_course",
		"description": "Average numeric grade per course (min 10 grades)",
		"dsl": "FETCH(c.name, AVG(g.grade) AS avg_grade, COUNT(g.id) AS grade_count) FROM courses AS c INCLUDE(enrollments.grades AS g) GROUPBY(c.name) HAVING(grade_count >= 10) ORDERBY(avg_grade DESC) LIMIT(10)",
		"postgres": "SELECT c.name, AVG(g.grade) AS avg_grade, COUNT(g.id) AS grade_count FROM courses c JOIN enrollments e ON e.course_id = c.id JOIN grades g ON g.enrollment_id = e.id GROUP BY c.name HAVING COUNT(g.id) >= 10 ORDER BY avg_grade DESC LIMIT 10",
		"mysql": "SELECT c.name, AVG(g.grade) AS avg_grade, COUNT(g.id) AS grade_count FROM courses c JOIN enrollments e ON e.course_id = c.id JOIN grades g ON g.enrollment_id = e.id GROUP BY c.name HAVING COUNT(g.id) >= 10 ORDER BY avg_grade DESC LIMIT 10",
		"mssql": "SELECT TOP 10 c.name, AVG(g.grade) AS avg_grade, COUNT(g.id) AS grade_count FROM courses c JOIN enrollments e ON e.course_id = c.id JOIN grades g ON g.enrollment_id = e.id GROUP BY c.name HAVING COUNT(g.id) >= 10 ORDER BY avg_grade DESC",
		"oracle": "SELECT c.name, AVG(g.grade) avg_grade, COUNT(g.id) grade_count FROM courses c JOIN enrollments e ON e.course_id = c.id JOIN grades g ON g.enrollment_id = e.id GROUP BY c.name HAVING COUNT(g.id) >= 10 ORDER BY avg_grade DESC FETCH FIRST 10 ROWS ONLY"
	},
	{
		"id": "students_with_3plus_enrolls",
		"description": "Students with at least 3 enrollments",
		"dsl": "FETCH(st.id, st.first_name, COUNT(e.id) AS enrolls) FROM students AS st INCLUDE(enrollments AS e) GROUPBY(st.id, st.first_name) HAVING(enrolls >= 3) ORDERBY(enrolls DESC, st.id ASC) LIMIT(20)",
		"postgres": "SELECT st.id, st.first_name, COUNT(e.id) AS enrolls FROM students st JOIN enrollments e ON e.student_id = st.id GROUP BY st.id, st.first_name HAVING COUNT(e.id) >= 3 ORDER BY enrolls DESC, st.id ASC LIMIT 20",
		"mysql": "SELECT st.id, st.first_name, COUNT(e.id) AS enrolls FROM students st JOIN enrollments e ON e.student_id = st.id GROUP BY st.id, st.first_name HAVING COUNT(e.id) >= 3 ORDER BY enrolls DESC, st.id ASC LIMIT 20",
		"mssql": "SELECT TOP 20 st.id, st.first_name, COUNT(e.id) AS enrolls FROM students st JOIN enrollments e ON e.student_id = st.id GROUP BY st.id, st.first_name HAVING COUNT(e.id) >= 3 ORDER BY enrolls DESC, st.id ASC",
		"oracle": "SELECT st.id, st.first_name, COUNT(e.id) enrolls FROM students st JOIN enrollments e ON e.student_id = st.id GROUP BY st.id, st.first_name HAVING COUNT(e.id) >= 3 ORDER BY enrolls DESC, st.id ASC FETCH FIRST 20 ROWS ONLY"
	},
	{
		"id": "top_teachers_salary_public",
		"description": "Top 10 teacher salaries in public schools",
		"dsl": "FETCH(t.id, t.first_name, t.last_name, t.salary) FROM teachers AS t INCLUDE(school AS sc) FILTER(sc.is_public = TRUE AND t.salary IS NOT NULL) ORDERBY(t.salary DESC) LIMIT(10)",
		"postgres": "SELECT t.id, t.first_name, t.last_name, t.salary FROM teachers t JOIN schools sc ON sc.id = t.school_id WHERE sc.is_public = TRUE AND t.salary IS NOT NULL ORDER BY t.salary DESC LIMIT 10",
		"mysql": "SELECT t.id, t.first_name, t.last_name, t.salary FROM teachers t JOIN schools sc ON sc.id = t.school_id WHERE sc.is_public = 1 AND t.salary IS NOT NULL ORDER BY t.salary DESC LIMIT 10",
		"mssql": "SELECT TOP 10 t.id, t.first_name, t.last_name, t.salary FROM teachers t JOIN schools sc ON sc.id = t.school_id WHERE sc.is_public = 1 AND t.salary IS NOT NULL ORDER BY t.salary DESC",
		"oracle": "SELECT t.id, t.first_name, t.last_name, t.salary FROM teachers t JOIN schools sc ON sc.id = t.school_id WHERE sc.is_public = 1 AND t.salary IS NOT NULL ORDER BY t.salary DESC FETCH FIRST 10 ROWS ONLY"
	},
	{
		"id": "classes_created_last_90d",
		"description": "Classes created in the last 90 days",
		"dsl": "FETCH(id, name, created_at) FROM classes FILTER(created_at >= DATEADD(DAY, NOW(),-90)) ORDERBY(created_at DESC) LIMIT(20)",
		"postgres": "SELECT id, name, created_at FROM classes WHERE created_at >= NOW() - INTERVAL '90 days' ORDER BY created_at DESC LIMIT 20",
		"mysql": "SELECT id, name, created_at FROM classes WHERE created_at >= (NOW() - INTERVAL 90 DAY) ORDER BY created_at DESC LIMIT 20",
		"mssql": "SELECT TOP 20 id, name, created_at FROM classes WHERE created_at >= DATEADD(DAY, -90, SYSDATETIME()) ORDER BY created_at DESC",
		"oracle": "SELECT id, name, created_at FROM classes WHERE created_at >= (SYSTIMESTAMP - INTERVAL '90' DAY) ORDER BY created_at DESC FETCH FIRST 20 ROWS ONLY"
	},
	{
		"id": "students_by_city",
		"description": "Total students by school city (top 10)",
		"dsl": "FETCH(sc.city, COUNT(st.id) AS cnt) FROM students AS st INCLUDE(class.school AS sc) GROUPBY(sc.city) ORDERBY(cnt DESC) LIMIT(10)",
		"postgres": "SELECT sc.city, COUNT(st.id) AS cnt FROM students st LEFT JOIN classes cl ON cl.id = st.class_id LEFT JOIN schools sc ON sc.id = cl.school_id GROUP BY sc.city ORDER BY cnt DESC LIMIT 10",
		"mysql": "SELECT sc.city, COUNT(st.id) AS cnt FROM students st LEFT JOIN classes cl ON cl.id = st.class_id LEFT JOIN schools sc ON sc.id = cl.school_id GROUP BY sc.city ORDER BY cnt DESC LIMIT 10",
		"mssql": "SELECT TOP 10 sc.city, COUNT(st.id) AS cnt FROM students st LEFT JOIN classes cl ON cl.id = st.class_id LEFT JOIN schools sc ON sc.id = cl.school_id GROUP BY sc.city ORDER BY cnt DESC",
		"oracle": "SELECT sc.city, COUNT(st.id) cnt FROM students st LEFT JOIN classes cl ON cl.id = st.class_id LEFT JOIN schools sc ON sc.id = cl.school_id GROUP BY sc.city ORDER BY cnt DESC FETCH FIRST 10 ROWS ONLY"
	},
	{
			"id": 13,
			"dsl": "FETCH(classes.name, COUNT(students.id) AS support_count) FROM classes INCLUDE(students) FILTER(students.preferences.needs_support == TRUE) GROUPBY(classes.name) ORDERBY(support_count DESC) LIMIT(5)",
			"postgres": "SELECT cl.name, COUNT(st.id) AS support_count FROM classes cl LEFT JOIN students st ON st.class_id = cl.id WHERE (st.preferences->>'needs_support')::boolean = TRUE GROUP BY cl.name ORDER BY support_count DESC LIMIT 5",
			"mysql": "SELECT cl.name, COUNT(st.id) AS support_count FROM classes cl LEFT JOIN students st ON st.class_id = cl.id WHERE JSON_EXTRACT(st.preferences,'$.needs_support') = true GROUP BY cl.name ORDER BY support_count DESC LIMIT 5",
			"mssql": "SELECT TOP 5 cl.name, COUNT(st.id) AS support_count FROM classes cl LEFT JOIN students st ON st.class_id = cl.id WHERE JSON_VALUE(st.preferences,'$.needs_support') = 'true' GROUP BY cl.name ORDER BY support_count DESC",
			"oracle": "SELECT cl.name, COUNT(st.id) support_count FROM classes cl LEFT JOIN students st ON st.class_id = cl.id WHERE JSON_VALUE(st.preferences,'$.needs_support') = 'true' GROUP BY cl.name ORDER BY support_count DESC FETCH FIRST 5 ROWS ONLY"
		},
		{
			"id": 14,
			"dsl": "FETCH(courses.name, AVG(grades.grade) AS avg_grade, COUNT(grades.id) AS grade_count) FROM courses INCLUDE(enrollments.grades) GROUPBY(courses.name) HAVING(grade_count >= 10) ORDERBY(avg_grade DESC) LIMIT(10)",
			"postgres": "SELECT c.name, AVG(g.grade) AS avg_grade, COUNT(g.id) AS grade_count FROM courses c JOIN enrollments e ON e.course_id = c.id JOIN grades g ON g.enrollment_id = e.id GROUP BY c.name HAVING COUNT(g.id) >= 10 ORDER BY avg_grade DESC LIMIT 10",
			"mysql": "SELECT c.name, AVG(g.grade) AS avg_grade, COUNT(g.id) AS grade_count FROM courses c JOIN enrollments e ON e.course_id = c.id JOIN grades g ON g.enrollment_id = e.id GROUP BY c.name HAVING COUNT(g.id) >= 10 ORDER BY avg_grade DESC LIMIT 10",
			"mssql": "SELECT TOP 10 c.name, AVG(g.grade) AS avg_grade, COUNT(g.id) AS grade_count FROM courses c JOIN enrollments e ON e.course_id = c.id JOIN grades g ON g.enrollment_id = e.id GROUP BY c.name HAVING COUNT(g.id) >= 10 ORDER BY avg_grade DESC",
			"oracle": "SELECT c.name, AVG(g.grade) avg_grade, COUNT(g.id) grade_count FROM courses c JOIN enrollments e ON e.course_id = c.id JOIN grades g ON g.enrollment_id = e.id GROUP BY c.name HAVING COUNT(g.id) >= 10 ORDER BY avg_grade DESC FETCH FIRST 10 ROWS ONLY"
		},
		{
			"id": 15,
			"dsl": "FETCH(students.id, students.first_name, COUNT(enrollments.id) AS enrolls) FROM students INCLUDE(enrollments) GROUPBY(students.id, students.first_name) HAVING(enrolls >= 3) ORDERBY(enrolls DESC, students.id ASC) LIMIT(20)",
			"postgres": "SELECT st.id, st.first_name, COUNT(e.id) AS enrolls FROM students st JOIN enrollments e ON e.student_id = st.id GROUP BY st.id, st.first_name HAVING COUNT(e.id) >= 3 ORDER BY enrolls DESC, st.id ASC LIMIT 20",
			"mysql": "SELECT st.id, st.first_name, COUNT(e.id) AS enrolls FROM students st JOIN enrollments e ON e.student_id = st.id GROUP BY st.id, st.first_name HAVING COUNT(e.id) >= 3 ORDER BY enrolls DESC, st.id ASC LIMIT 20",
			"mssql": "SELECT TOP 20 st.id, st.first_name, COUNT(e.id) AS enrolls FROM students st JOIN enrollments e ON e.student_id = st.id GROUP BY st.id, st.first_name HAVING COUNT(e.id) >= 3 ORDER BY enrolls DESC, st.id ASC",
			"oracle": "SELECT st.id, st.first_name, COUNT(e.id) enrolls FROM students st JOIN enrollments e ON e.student_id = st.id GROUP BY st.id, st.first_name HAVING COUNT(e.id) >= 3 ORDER BY enrolls DESC, st.id ASC FETCH FIRST 20 ROWS ONLY"
		},
		{
			"id": 16,
			"dsl": "FETCH(SUBSTRING(email, INDEXOF(email,'@')+1) AS domain, COUNT(*) AS cnt) FROM students GROUPBY(domain) ORDERBY(cnt DESC) LIMIT(5)",
			"postgres": "SELECT SPLIT_PART(email,'@',2) AS domain, COUNT(*) AS cnt FROM students GROUP BY SPLIT_PART(email,'@',2) ORDER BY cnt DESC LIMIT 5",
			"mysql": "SELECT SUBSTRING_INDEX(email,'@',-1) AS domain, COUNT(*) AS cnt FROM students GROUP BY SUBSTRING_INDEX(email,'@',-1) ORDER BY cnt DESC LIMIT 5",
			"mssql": "SELECT SUBSTRING(email, CHARINDEX('@',email)+1, LEN(email)) AS domain, COUNT(*) AS cnt FROM students GROUP BY SUBSTRING(email, CHARINDEX('@',email)+1, LEN(email)) ORDER BY cnt DESC",
			"oracle": "SELECT SUBSTR(email, INSTR(email,'@')+1) AS domain, COUNT(*) AS cnt FROM students GROUP BY SUBSTR(email, INSTR(email,'@')+1) ORDER BY cnt DESC FETCH FIRST 5 ROWS ONLY"
		},
		{
			"id": 17,
			"dsl": "FETCH(school.city, COUNT(students.id) AS cnt) FROM students INCLUDE(class.school) GROUPBY(school.city) ORDERBY(cnt DESC) LIMIT(10)",
			"postgres": "SELECT sc.city, COUNT(st.id) AS cnt FROM students st LEFT JOIN classes cl ON cl.id = st.class_id LEFT JOIN schools sc ON sc.id = cl.school_id GROUP BY sc.city ORDER BY cnt DESC LIMIT 10",
			"mysql": "SELECT sc.city, COUNT(st.id) AS cnt FROM students st LEFT JOIN classes cl ON cl.id = st.class_id LEFT JOIN schools sc ON sc.id = cl.school_id GROUP BY sc.city ORDER BY cnt DESC LIMIT 10",
			"mssql": "SELECT TOP 10 sc.city, COUNT(st.id) AS cnt FROM students st LEFT JOIN classes cl ON cl.id = st.class_id LEFT JOIN schools sc ON sc.id = cl.school_id GROUP BY sc.city ORDER BY cnt DESC",
			"oracle": "SELECT sc.city, COUNT(st.id) cnt FROM students st LEFT JOIN classes cl ON cl.id = st.class_id LEFT JOIN schools sc ON sc.id = cl.school_id GROUP BY sc.city ORDER BY cnt DESC FETCH FIRST 10 ROWS ONLY"
		}
]
